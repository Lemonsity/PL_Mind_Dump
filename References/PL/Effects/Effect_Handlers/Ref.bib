
@article{brachthauser_effects_2020,
	title = {Effects as capabilities: effect handlers and lightweight effect polymorphism},
	volume = {4},
	shorttitle = {Effects as capabilities},
	url = {https://dl.acm.org/doi/10.1145/3428194},
	doi = {10.1145/3428194},
	abstract = {Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption.  We present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which side effects a computation might have. In Effekt, effect types express which capabilities a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about purity, we demonstrate that it simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat all functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style.},
	number = {OOPSLA},
	urldate = {2024-08-12},
	journal = {Proc. ACM Program. Lang.},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp and Ostermann, Klaus},
	month = nov,
	year = {2020},
	keywords = {Effect\_Capabilities, Effect\_Handlers, Effects\_Unified},
	pages = {126:1--126:30},
}

@article{pretnar_introduction_2015,
	series = {The 31st {Conference} on the {Mathematical} {Foundations} of {Programming} {Semantics} ({MFPS} {XXXI}).},
	title = {An {Introduction} to {Algebraic} {Effects} and {Handlers}. {Invited} tutorial paper},
	volume = {319},
	issn = {1571-0661},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066115000705},
	doi = {10.1016/j.entcs.2015.12.003},
	abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type \& effect system, show how one can reason about effects, and give pointers for further reading.},
	urldate = {2024-08-12},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Pretnar, Matija},
	month = dec,
	year = {2015},
	keywords = {algebraic effects, effect system, handlers, logic, semantics, tutorial},
	pages = {19--35},
}

@article{plotkin_handling_2013,
	title = {Handling {Algebraic} {Effects}},
	volume = {Volume 9, Issue 4},
	issn = {1860-5974},
	url = {https://lmcs.episciences.org/705},
	doi = {10.2168/LMCS-9(4:23)2013},
	abstract = {Algebraic effects are computational effects that can be represented by an equational theory whose operations produce the effects at hand. The free model of this theory induces the expected computational monad for the corresponding effect. Algebraic effects include exceptions, state, nondeterminism, interactive input/output, and time, and their combinations. Exception handling, however, has so far received no algebraic treatment. We present such a treatment, in which each handler yields a model of the theory for exceptions, and each handling construct yields the homomorphism induced by the universal property of the free model. We further generalise exception handlers to arbitrary algebraic effects. The resulting programming construct includes many previously unrelated examples from both theory and practice, including relabelling and restriction in Milner's CCS, timeout, rollback, and stream redirection.},
	urldate = {2024-08-13},
	journal = {Logical Methods in Computer Science},
	author = {Plotkin, Gordon D. and Pretnar, Matija},
	month = dec,
	year = {2013},
	note = {Publisher: Episciences.org},
}

@inproceedings{leijen_koka_2014,
	title = {Koka: {Programming} with {Row} {Polymorphic} {Effect} {Types}},
	shorttitle = {Koka},
	url = {https://www.microsoft.com/en-us/research/publication/koka-programming-with-row-polymorphic-effect-types-2/},
	abstract = {We propose a programming model where effects are treated in a disciplined way, and where the potential side-effects of a function are apparent in its type signature. The type and effect of expressions can also be inferred automatically, and we describe a polymorphic type inference system based on Hindley-Milner style inference. A novel feature is […]},
	language = {en-US},
	urldate = {2024-08-20},
	author = {Leijen, Daan},
	month = mar,
	year = {2014},
}

@article{plotkin_computational_2004,
	series = {Proceedings of the {Workshop} on {Domains} {VI}},
	title = {Computational {Effects} and {Operations}: {An} {Overview}},
	volume = {73},
	issn = {1571-0661},
	shorttitle = {Computational {Effects} and {Operations}},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066104050893},
	doi = {10.1016/j.entcs.2004.08.008},
	urldate = {2024-08-21},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Plotkin, Gordon and Power, John},
	month = oct,
	year = {2004},
	pages = {149--163},
}

@article{leijen_koka_2013,
	title = {Koka: {Programming} with {Row}-{Polymorphic} {Effect} {Types}},
	shorttitle = {Koka},
	url = {https://www.microsoft.com/en-us/research/publication/koka-programming-with-row-polymorphic-effect-types/},
	abstract = {Note: This is an updated article: a previous version of this article contained a wrong lemma and corresponding mistakes in various proofs of Section 5. We propose a programming model where effects are treated in a disciplined way, and where the potential side-effects of a function are apparent in its type signature. The type and […]},
	language = {en-US},
	urldate = {2024-08-21},
	author = {Leijen, Daan},
	month = aug,
	year = {2013},
}

@article{yoshioka_abstracting_2024,
	title = {Abstracting {Effect} {Systems} for {Algebraic} {Effect} {Handlers}},
	volume = {8},
	url = {https://dl.acm.org/doi/10.1145/3674641},
	doi = {10.1145/3674641},
	abstract = {Many effect systems for algebraic effect handlers are designed to guarantee that all invoked effects are handled adequately. However, respective researchers have developed their own effect systems that differ in how to represent the collections of effects that may happen. This situation results in blurring what is required for the representation and manipulation of effect collections in a safe effect system.    In this work, we present a language λEA equipped with an effect system that abstracts the existing effect systems for algebraic effect handlers. The effect system of λEA is parameterized over effect algebras, which abstract the representation and manipulation of effect collections in safe effect systems. We prove the type-and-effect safety of λEA by assuming that a given effect algebra meets certain properties called safety conditions. As a result, we can obtain the safety properties of a concrete effect system by proving that an effect algebra corresponding to the concrete system meets the safety conditions. We also show that effect algebras meeting the safety conditions are expressive enough to accommodate some existing effect systems, each of which represents effect collections in a different style. Our framework can also differentiate the safety aspects of the effect collections of the existing effect systems. To this end, we extend λEA and the safety conditions to lift coercions and type-erasure semantics, propose other effect algebras including ones for which no effect system has been studied in the literature, and compare which effect algebra is safe and which is not for the extensions.},
	number = {ICFP},
	urldate = {2024-08-31},
	journal = {Proc. ACM Program. Lang.},
	author = {Yoshioka, Takuma and Sekiyama, Taro and Igarashi, Atsushi},
	month = aug,
	year = {2024},
	pages = {252:455--252:484},
}

@article{song_specification_2024,
	title = {Specification and {Verification} for {Unrestricted} {Algebraic} {Effects} and {Handling}},
	volume = {8},
	url = {https://dl.acm.org/doi/10.1145/3674656},
	doi = {10.1145/3674656},
	abstract = {Programming with user-defined effects and effect handlers has many practical use cases involving imperative effects. Additionally, it is natural and powerful to use multi-shot effect handlers for non-deterministic or probabilistic programs that allow backtracking to compute a comprehensive outcome. Existing works for verifying effect handlers are restricted in one of three ways: i) permitting multi-shot continuations under pure setting; ii) allowing heap manipulation for only one-shot continuations; or iii) allowing multi-shot continuations with heap-manipulation but under a restricted frame rule.
 

 
This work proposes a novel calculus called Effectful Specification Logic (ESL) to support unrestricted effect handlers, where zero-/one-/multi-shot continuations can co-exist with imperative effects and higher-order constructs. ESL captures behaviors in stages, and provides precise models to support invoked effects, handlers and continuations. To show its feasibility, we prototype an automated verification system for this novel specification logic, prove its soundness, report on useful case studies, and present experimental results. With this proposal, we have provided an extended specification logic that is capable of modeling arbitrary imperative higher-order programs with algebraic effects and continuation-enabled handlers.},
	number = {ICFP},
	urldate = {2024-09-03},
	journal = {Specification and Verification for Unrestricted Algebraic Effects and Handling},
	author = {Song, Yahui and Foo, Darius and Chin, Wei-Ngan},
	month = aug,
	year = {2024},
	pages = {267:909--267:937},
}

@inproceedings{lindley_be_2017,
	address = {New York, NY, USA},
	series = {{POPL} '17},
	title = {Do be do be do},
	isbn = {978-1-4503-4660-3},
	url = {https://dl.acm.org/doi/10.1145/3009837.3009897},
	doi = {10.1145/3009837.3009897},
	abstract = {We explore the design and implementation of Frank, a strict functional programming language with a bidirectional effect type system designed from the ground up around a novel variant of Plotkin and Pretnar's effect handler abstraction.  Effect handlers provide an abstraction for modular effectful programming: a handler acts as an interpreter for a collection of commands whose interfaces are statically tracked by the type system. However, Frank eliminates the need for an additional effect handling construct by generalising the basic mechanism of functional abstraction itself. A function is simply the special case of a Frank operator that interprets no commands. Moreover, Frank's operators can be multihandlers which simultaneously interpret commands from several sources at once, without disturbing the direct style of functional programming with values.  Effect typing in Frank employs a novel form of effect polymorphism which avoid mentioning effect variables in source code. This is achieved by propagating an ambient ability inwards, rather than accumulating unions of potential effects outwards.  We introduce Frank by example, and then give a formal account of the Frank type system and its semantics. We introduce Core Frank by elaborating Frank operators into functions, case expressions, and unary handlers, and then give a sound small-step operational semantics for Core Frank.  Programming with effects and handlers is in its infancy. We contribute an exploration of future possibilities, particularly in combination with other forms of rich type system.},
	urldate = {2024-09-09},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Lindley, Sam and McBride, Conor and McLaughlin, Craig},
	month = jan,
	year = {2017},
	pages = {500--514},
}

@article{convent_doo_2020,
	title = {Doo bee doo bee doo},
	volume = {30},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/doo-bee-doo-bee-doo/DEC5F8FDABF7DE3088270E07392320DD},
	doi = {10.1017/S0956796820000039},
	abstract = {We explore the design and implementation of Frank, a strict functional programming language with a bidirectional effect type system designed from the ground up around a novel variant of Plotkin and Pretnar’s effect handler abstraction. Effect handlers provide an abstraction for modular effectful programming: a handler acts as an interpreter for a collection of commands whose interfaces are statically tracked by the type system. However, Frank eliminates the need for an additional effect handling construct by generalising the basic mechanism of functional abstraction itself. A function is but the special case of a Frank operator that interprets no commands. Moreover, Frank’s operators can be multihandlers which simultaneously interpret commands from several sources at once, without disturbing the direct style of functional programming with values. Effect typing in Frank employs a novel form of effect polymorphism which avoids mentioning effect variables in source code. This is achieved by propagating an ambient ability inwards, rather than accumulating unions of potential effects outwards. With the ambient ability describing the effects that are available at a certain point in the code, it can become necessary to reconfigure access to the ambient ability. A primary goal is to be able to encapsulate internal effects, eliminating a phenomenon we call effect pollution. Moreover, it is sometimes desirable to rewire the effect flow between effectful library components. We propose adaptors as a means for supporting both effect encapsulation and more general rewiring. Programming with effects and handlers is in its infancy. We contribute an exploration of future possibilities, particularly in combination with other forms of rich type systems.},
	language = {en},
	urldate = {2024-09-09},
	journal = {Journal of Functional Programming},
	author = {Convent, Lukas and Lindley, Sam and Mcbride, Conor and Mclaughlin, Craig},
	month = jan,
	year = {2020},
	pages = {e9},
}

@article{kammar_handlers_2013,
	title = {Handlers in action},
	volume = {48},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/2544174.2500590},
	doi = {10.1145/2544174.2500590},
	abstract = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
	number = {9},
	urldate = {2024-09-11},
	journal = {SIGPLAN Not.},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	month = sep,
	year = {2013},
	pages = {145--158},
}

@inproceedings{schrijvers_monad_2019,
	address = {New York, NY, USA},
	series = {Haskell 2019},
	title = {Monad transformers and modular algebraic effects: what binds them together},
	isbn = {978-1-4503-6813-1},
	shorttitle = {Monad transformers and modular algebraic effects},
	url = {https://dl.acm.org/doi/10.1145/3331545.3342595},
	doi = {10.1145/3331545.3342595},
	abstract = {For over two decades, monad transformers have been the main modular approach for expressing purely functional side-effects in Haskell. Yet, in recent years algebraic effects have emerged as an alternative whose popularity is growing. While the two approaches have been well-studied, there is still confusion about their relative merits and expressiveness, especially when it comes to their comparative modularity. This paper clarifies the connection between the two approaches—some of which is folklore—and spells out consequences that we believe should be better known. We characterise a class of algebraic effects that is modular, and show how these correspond to a specific class of monad transformers. In particular, we show that our modular algebraic effects gives rise to monad transformers. Moreover, every monad transformer for algebraic operations gives rise to a modular effect handler.},
	urldate = {2024-09-10},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Symposium} on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Schrijvers, Tom and Piróg, Maciej and Wu, Nicolas and Jaskelioff, Mauro},
	month = aug,
	year = {2019},
	keywords = {Effect\_Handlers, Monad},
	pages = {98--113},
}

@inproceedings{hillerstrom_liberating_2016,
	address = {New York, NY, USA},
	series = {{TyDe} 2016},
	title = {Liberating effects with rows and handlers},
	isbn = {978-1-4503-4435-7},
	url = {https://dl.acm.org/doi/10.1145/2976022.2976033},
	doi = {10.1145/2976022.2976033},
	abstract = {Algebraic effects and effect handlers provide a modular abstraction for effectful programming. They support user-defined effects, as in Haskell, in conjunction with direct-style effectful programming, as in ML. They also present a structured interface to programming with delimited continuations.  In order to be modular, it is necessary for an effect type system to support extensible effects. Row polymorphism is a natural abstraction for modelling extensibility at the level of types. In this paper we argue that the abstraction required to implement extensible effects and their handlers is exactly row polymorphism.  We use the Links functional web programming language as a platform to substantiate this claim. Links is a natural starting point as it uses row polymorphism for polymorphic variants, records, and its built-in effect types. It also has infrastructure for manipulating continuations. Through a small extension to Links we smoothly add support for effect handlers, making essential use of rows in the frontend and first-class continuations in the backend.  We demonstrate the usability of our implementation by modelling the mathematical game of Nim as an abstract computation. We interpret this abstract computation in a variety of ways, illustrating how rows and handlers support modularity and smooth composition of effectful computations.  We present a core calculus of row-polymorphic effects and handlers based on a variant of A-normal form used in the intermediate representation of Links. We give an operational semantics for the calculus and a novel generalisation of the CEK machine that implements the operational semantics, and prove that the two coincide.},
	urldate = {2024-09-16},
	booktitle = {Proceedings of the 1st {International} {Workshop} on {Type}-{Driven} {Development}},
	publisher = {Association for Computing Machinery},
	author = {Hillerström, Daniel and Lindley, Sam},
	month = sep,
	year = {2016},
	keywords = {Row},
	pages = {15--27},
}

@inproceedings{petricek_coeffects_2014,
	address = {New York, NY, USA},
	series = {{ICFP} '14},
	title = {Coeffects: a calculus of context-dependent computation},
	isbn = {978-1-4503-2873-9},
	shorttitle = {Coeffects},
	url = {https://dl.acm.org/doi/10.1145/2628136.2628160},
	doi = {10.1145/2628136.2628160},
	abstract = {The notion of context in functional languages no longer refers just to variables in scope. Context can capture additional properties of variables (usage patterns in linear logics; caching requirements in dataflow languages) as well as additional resources or properties of the execution environment (rebindable resources; platform version in a cross-platform application). The recently introduced notion of coeffects captures the latter, whole-context properties, but it failed to capture fine-grained per-variable properties.We remedy this by developing a generalized coeffect system with annotations indexed by a coeffect shape. By instantiating a concrete shape, our system captures previously studied flat (whole-context) coeffects, but also structural (per-variable) coeffects, making coeffect analyses more useful. We show that the structural system enjoys desirable syntactic properties and we give a categorical semantics using extended notions of indexed comonad.The examples presented in this paper are based on analysis of established language features (liveness, linear logics, dataflow, dynamic scoping) and we argue that such context-aware properties will also be useful for future development of languages for increasingly heterogeneous and distributed platforms.},
	urldate = {2024-09-16},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {Association for Computing Machinery},
	author = {Petricek, Tomas and Orchard, Dominic and Mycroft, Alan},
	month = aug,
	year = {2014},
	keywords = {Effect\_Capabilities, Implicit\_Argument},
	pages = {123--135},
}

@article{brachthauser_effekt_2020,
	title = {Effekt: {Capability}-passing style for type- and effect-safe, extensible effect handlers in {Scala}},
	volume = {30},
	issn = {0956-7968, 1469-7653},
	shorttitle = {Effekt},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/effekt-capabilitypassing-style-for-type-and-effectsafe-extensible-effect-handlers-in-scala/A19680B18FB74AD95F8D83BC4B097D4F},
	doi = {10.1017/S0956796820000027},
	abstract = {Effect handlers are a promising way to structure effectful programs in a modular way. We present the Scala library Effekt, which is centered around capability passing and implemented in terms of a monad for multi-prompt delimited continuations. Effekt is the first library implementation of effect handlers that supports effect safety and effect polymorphism without resorting to type-level programming. We describe a novel way of achieving effect safety using intersection types and path-dependent types. The effect system of our library design fits well into the programming paradigm of capability passing and is inspired by the effect system of Zhang \& Myers (2019, Proc. ACM Program. Lang.3(POPL), 5:1-5:29). Capabilities carry an abstract type member, which represents an individual effect type and reflects the use of the capability on the type level. We represent effect rows as the contravariant intersection of effect types. Handlers introduce capabilities and remove components of the intersection type. Reusing the existing type system of Scala, we get effect subtyping and effect polymorphism for free.},
	language = {en},
	urldate = {2024-09-20},
	journal = {Journal of Functional Programming},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp and Ostermann, Klaus},
	month = jan,
	year = {2020},
	keywords = {Effect\_Capabilities},
	pages = {e8},
}

@inproceedings{brachthauser_effekt_2017,
	address = {New York, NY, USA},
	series = {{SCALA} 2017},
	title = {Effekt: extensible algebraic effects in {Scala} (short paper)},
	isbn = {978-1-4503-5529-2},
	shorttitle = {Effekt},
	url = {https://dl.acm.org/doi/10.1145/3136000.3136007},
	doi = {10.1145/3136000.3136007},
	abstract = {Algebraic effects are an interesting way to structure effectful programs and offer new modularity properties. We present the Scala library Effekt, which is implemented in terms of a monad for multi-prompt delimited continuations and centered around capability passing. This makes the newly proposed feature of implicit function types a perfect fit for the syntax of our library. Basing the library design on capability passing and a polymorphic embedding of effect handlers furthermore opens up interesting dimensions of extensibility. Preliminary benchmarks comparing Effekt with an established library suggest significant speedups.},
	urldate = {2024-09-20},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {International} {Symposium} on {Scala}},
	publisher = {Association for Computing Machinery},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp},
	month = oct,
	year = {2017},
	keywords = {Effect\_Capabilities},
	pages = {67--72},
}

@misc{bauer_what_2019,
	title = {What is algebraic about algebraic effects and handlers?},
	url = {http://arxiv.org/abs/1807.05923},
	doi = {10.48550/arXiv.1807.05923},
	abstract = {This note recapitulates and expands the contents of a tutorial on the mathematical theory of algebraic effects and handlers which I gave at the Dagstuhl seminar 18172 "Algebraic effect handlers go mainstream". It is targeted roughly at the level of a doctoral student with some amount of mathematical training, or at anyone already familiar with algebraic effects and handlers as programming concepts who would like to know what they have to do with algebra. We draw an uninterrupted line of thought between algebra and computational effects. We begin on the mathematical side of things, by reviewing the classic notions of universal algebra: signatures, algebraic theories, and their models. We then generalize and adapt the theory so that it applies to computational effects. In the last step we replace traditional mathematical notation with one that is closer to programming languages.},
	urldate = {2024-09-20},
	publisher = {arXiv},
	author = {Bauer, Andrej},
	month = mar,
	year = {2019},
	note = {arXiv:1807.05923 [cs]},
	keywords = {Computer Science - Programming Languages, 08A70, Computer Science - Logic in Computer Science},
}

@inproceedings{kammar_handlers_2013-1,
	address = {New York, NY, USA},
	series = {{ICFP} '13},
	title = {Handlers in action},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500590},
	doi = {10.1145/2500365.2500590},
	abstract = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
	urldate = {2024-09-27},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {Association for Computing Machinery},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	month = sep,
	year = {2013},
	keywords = {Deep\_Handler},
	pages = {145--158},
}

@article{dumas_hilbert-post_nodate,
	title = {Hilbert-{Post} completeness for the state and the exception effects},
	abstract = {A theory is complete if it does not contain a contradiction, while all of its proper extensions do. In this paper, ﬁrst we introduce a relative notion of syntactic completeness; then we prove that adding exceptions to a programming language can be done in such a way that the completeness of the language is not made worse. These proofs are formalized in a logical system which is close to the usual syntax for exceptions, and they have been checked with the proof assistant Coq.},
	language = {en},
	author = {Dumas, Jean-Guillaume and Duval, Dominique and Ekici, Burak and Pous, Damien and Reynaud, Jean-Claude},
}

@inproceedings{lindley_row-based_2012,
	address = {New York, NY, USA},
	series = {{TLDI} '12},
	title = {Row-based effect types for database integration},
	isbn = {978-1-4503-1120-5},
	url = {https://dl.acm.org/doi/10.1145/2103786.2103798},
	doi = {10.1145/2103786.2103798},
	abstract = {We present CoreLinks, a call-by-value variant of System F with row polymorphism, row-based effect types, and implicit subkinding, which forms the basis for the Links web programming language. We focus on extensions to CoreLinks for database programming. The effect types support abstraction over database queries, while ensuring that queries are translated predictably to idiomatic and efficient SQL at run-time. Subkinding statically enforces the constraint that queries must return a list of records of base type. Polymorphism over the presence of record labels supports abstraction over database queries, inserts, deletes and updates.},
	urldate = {2024-09-30},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} workshop on {Types} in language design and implementation},
	publisher = {Association for Computing Machinery},
	author = {Lindley, Sam and Cheney, James},
	month = jan,
	year = {2012},
	pages = {91--102},
}

@article{biernacki_abstracting_2019,
	title = {Abstracting algebraic effects},
	volume = {3},
	url = {https://dl.acm.org/doi/10.1145/3290319},
	doi = {10.1145/3290319},
	abstract = {Proposed originally by Plotkin and Pretnar, algebraic effects and their handlers are a leading-edge approach to computational effects: exceptions, mutable state, nondeterminism, and such. Appreciated for their elegance and expressiveness, they are now progressing into mainstream functional programming languages. In this paper, we introduce and examine programming language constructs that back adoption of programming with algebraic effects on a larger scale in a modular fashion by providing mechanisms for abstraction. We propose two such mechanisms: existential effects (which hide the details of a particular effect from the user) and local effects (which guarantee that no code coming from the outside can interfere with a given effect). The main technical difficulty arises from the dynamic nature of coupling an effectful operation with the right handler during execution, but, as we show in this paper, a carefully designed type system can ensure that this will not break the abstraction. Our main contribution is a novel calculus for algebraic effects and handlers, called λHEL, equipped with local and existential algebraic effects, in which the dynamic nature of handlers is kept in check by typed runtime coercions. As a proof of concept, we present an experimental programming language based on our calculus, which provides strong abstraction mechanisms via an ML-style module system.},
	number = {POPL},
	urldate = {2024-10-06},
	journal = {Helium},
	author = {Biernacki, Dariusz and Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	month = jan,
	year = {2019},
	pages = {6:1--6:28},
}

@article{biernacki_handle_2017,
	title = {Handle with care: relational interpretation of algebraic effects and handlers},
	volume = {2},
	shorttitle = {Handle with care},
	url = {https://dl.acm.org/doi/10.1145/3158096},
	doi = {10.1145/3158096},
	abstract = {Algebraic effects and handlers have received a lot of attention recently, both from the theoretical point of view and in practical language design. This stems from the fact that algebraic effects give the programmer unprecedented freedom to define, combine, and interpret computational effects. This plenty-of-rope, however, demands not only a deep understanding of the underlying semantics, but also access to practical means of reasoning about effectful code, including correctness and program equivalence. In this paper we tackle this problem by constructing a step-indexed relational interpretation of a call-by-value calculus with algebraic effect handlers and a row-based polymorphic type-and-effect system. Our calculus, while striving for simplicity, enjoys desirable theoretical properties, and is close to the cores of programming languages with algebraic effects used in the wild, while the logical relation we build for it can be used to reason about non-trivial properties, such as contextual equivalence and contextual approximation of programs. Our development has been fully formalised in the Coq proof assistant.},
	number = {POPL},
	urldate = {2024-10-06},
	journal = {Proc. ACM Program. Lang.},
	author = {Biernacki, Dariusz and Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	month = dec,
	year = {2017},
	pages = {8:1--8:30},
}

@article{xie_effect_2020,
	title = {Effect handlers, evidently},
	volume = {4},
	url = {https://dl.acm.org/doi/10.1145/3408981},
	doi = {10.1145/3408981},
	abstract = {Algebraic effect handlers are a powerful way to incorporate effects in a programming language. Sometimes perhaps even \_too\_ powerful. In this article we define a restriction of general effect handlers with \_scoped resumptions\_. We argue one can still express all important effects, while improving reasoning about effect handlers. Using the newly gained guarantees, we define a sound and coherent evidence translation for effect handlers, which directly passes the handlers as evidence to each operation. We prove full soundness and coherence of the translation into plain lambda calculus. The evidence in turn enables efficient implementations of effect operations; in particular, we show we can execute tail-resumptive operations \_in place\_ (without needing to capture the evaluation context), and how we can replace the runtime search for a handler by indexing with a constant offset.},
	number = {ICFP},
	urldate = {2024-10-08},
	journal = {Proc. ACM Program. Lang.},
	author = {Xie, Ningning and Brachthäuser, Jonathan Immanuel and Hillerström, Daniel and Schuster, Philipp and Leijen, Daan},
	month = aug,
	year = {2020},
	pages = {99:1--99:29},
}

@inproceedings{xie_effect_2020-1,
	address = {New York, NY, USA},
	series = {Haskell 2020},
	title = {Effect handlers in {Haskell}, evidently},
	isbn = {978-1-4503-8050-8},
	url = {https://dl.acm.org/doi/10.1145/3406088.3409022},
	doi = {10.1145/3406088.3409022},
	abstract = {Algebraic effect handlers offer an alternative to monads to incorporate effects in Haskell. In recent work Xie \_et al.\_ show how to give semantics to effect handlers in terms of plain polymorphic lambda calculus through \_evidence translation\_. Besides giving precise semantics, this translation also allows for potentially more efficient implementations. Here we present the first implementation of this technique as a library for effect handlers in Haskell. We show how the design naturally leads to a concise effect interface and how evidence translation enables evaluating \_tail resumptive\_ operations \_in-place\_. We give detailed benchmark results where our library performs well with respect to other approaches.},
	urldate = {2024-10-08},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} {International} {Symposium} on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Xie, Ningning and Leijen, Daan},
	month = aug,
	year = {2020},
	pages = {95--108},
	
}

@article{plotkin_algebraic_nodate,
	title = {Algebraic {Operations} and {Generic} {Effects}},
	abstract = {Given a complete and cocomplete symmetric monoidal closed category V and a symmetric monoidal V-category C with cotensors and a strong V-monad T on C, we investigate axioms under which an Ob C-indexed family of operations of the form αx : (T x)v → (T x)w provides semantics for algebraic operations on the computational λ-calculus. We recall a deﬁnition for which we have elsewhere given adequacy results, and we show that an enrichment of it is equivalent to a range of other possible natural deﬁnitions of algebraic operation. In particular, we deﬁne the notion of generic effect and show that to give a generic effect is equivalent to giving an algebraic operation. We further show how the usual monadic semantics of the computational λ-calculus extends uniformly to incorporate generic effects. We outline examples and non-examples and we show that our deﬁnition also enriches one for call-by-name languages with effects.},
	language = {en},
	author = {Plotkin, Gordon and Power, John and Moggi, Eugenio},
	
}

@article{zyuzin_contextual_2021,
	title = {Contextual modal types for algebraic effects and handlers},
	volume = {5},
	url = {https://dl.acm.org/doi/10.1145/3473580},
	doi = {10.1145/3473580},
	abstract = {Programming languages with algebraic effects often track the computations’ effects using type-and-effect systems. In this paper, we propose to view an algebraic effect theory of a computation as a variable context; consequently, we propose to track algebraic effects of a computation with contextual modal types. We develop ECMTT, a novel calculus which tracks algebraic effects by a contextualized variant of the modal □ (necessity) operator, that it inherits from Contextual Modal Type Theory (CMTT). Whereas type-and-effect systems add effect annotations on top of a prior programming language, the effect annotations in ECMTT are inherent to the language, as they are managed by programming constructs corresponding to the logical introduction and elimination forms for the □ modality. Thus, the type-and-effect system of ECMTT is actually just a type system. Our design obtains the properties of local soundness and completeness, and determines the operational semantics solely by β-reduction, as customary in other logic-based calculi. In this view, effect handlers arise naturally as a witness that one context (i.e., algebraic theory) can be reached from another, generalizing explicit substitutions from CMTT. To the best of our knowledge, ECMTT is the first system to relate algebraic effects to modal types. We also see it as a step towards providing a correspondence in the style of Curry and Howard that may transfer a number of results from the fields of modal logic and modal type theory to that of algebraic effects.},
	number = {ICFP},
	urldate = {2024-10-16},
	journal = {Proc. ACM Program. Lang.},
	author = {Zyuzin, Nikita and Nanevski, Aleksandar},
	month = aug,
	year = {2021},
	pages = {75:1--75:29},
	
}

@article{xie_parallel_2024,
	title = {Parallel {Algebraic} {Effect} {Handlers}},
	volume = {8},
	url = {https://dl.acm.org/doi/10.1145/3674651},
	doi = {10.1145/3674651},
	abstract = {Algebraic effect handlers support composable and structured control-flow  abstraction. However, existing designs of algebraic effects often require  effects to be executed sequentially. This paper studies parallel algebraic  effect handlers. In particular, we formalize λp, a lambda calculus  which models two key features, effect handlers and parallelizable computations,  the latter of which takes the form of a for expression, inspired by the Dex  programming language. We present various interesting examples expressible in our  calculus. To show that our design can be implemented in a type-safe way, we  present a higher-order polymorphic lambda calculus Fp that extends λp  with a lightweight value dependent type system, and prove that Fp  preserves the semantics of λp and enjoys syntactic type soundness.  Lastly, we provide an implementation of the language design as a Haskell  library, which mirrors both λp and Fp and reveals new  connections to free applicative functors. All examples presented can be encoded  in the Haskell implementation. We believe this paper is the first to study the  combination of user-defined effect handlers and parallel computations,  and it is our hope that it provides a basis for future designs and  implementations of parallel algebraic effect handlers.},
	number = {ICFP},
	urldate = {2024-10-17},
	journal = {Proc. ACM Program. Lang.},
	author = {Xie, Ningning and Johnson, Daniel D. and Maclaurin, Dougal and Paszke, Adam},
	month = aug,
	year = {2024},
	pages = {262:756--262:788},
	
}

@article{zhang_abstraction-safe_2019,
	title = {Abstraction-safe effect handlers via tunneling},
	volume = {3},
	url = {https://dl.acm.org/doi/10.1145/3290318},
	doi = {10.1145/3290318},
	abstract = {Algebraic effect handlers offer a unified approach to expressing control-flow transfer idioms such as exceptions, iteration, and async/await. Unfortunately, previous attempts to make these handlers type-safe have failed to support the fundamental principle of modular reasoning for higher-order abstractions. We demonstrate that abstraction-safe algebraic effect handlers are possible by giving them a new semantics. The key insight is that code should only handle effects it is aware of. In our approach, the type system guarantees all effects are handled, but it is impossible for higher-order, effect-polymorphic code to accidentally handle effects raised by functions passed in; such effects tunnel through the higher-order, calling procedures polymorphic to them. By contrast, the possibility of accidental handling threatens previous designs for algebraic effect handlers. We prove that our design is not only type-safe, but also abstraction-safe. Using a logical-relations model that we prove sound with respect to contextual equivalence, we derive previously unattainable program equivalence results. Our mechanism offers a viable approach for future language designs aiming for effect handlers with strong abstraction guarantees.},
	number = {POPL},
	urldate = {2024-10-20},
	journal = {Proc. ACM Program. Lang.},
	author = {Zhang, Yizhou and Myers, Andrew C.},
	month = jan,
	year = {2019},
	pages = {5:1--5:29},
	
}

@inproceedings{zhang_accepting_2016,
	address = {New York, NY, USA},
	series = {{PLDI} '16},
	title = {Accepting blame for safe tunneled exceptions},
	isbn = {978-1-4503-4261-2},
	url = {https://dl.acm.org/doi/10.1145/2908080.2908086},
	doi = {10.1145/2908080.2908086},
	abstract = {Unhandled exceptions crash programs, so a compile-time check that exceptions are handled should in principle make software more reliable. But designers of some recent languages have argued that the benefits of statically checked exceptions are not worth the costs. We introduce a new statically checked exception mechanism that addresses the problems with existing checked-exception mechanisms. In particular, it interacts well with higher-order functions and other design patterns. The key insight is that whether an exception should be treated as a "checked" exception is not a property of its type but rather of the context in which the exception propagates. Statically checked exceptions can "tunnel" through code that is oblivious to their presence, but the type system nevertheless checks that these exceptions are handled. Further, exceptions can be tunneled without being accidentally caught, by expanding the space of exception identifiers to identify the exception-handling context. The resulting mechanism is expressive and syntactically light, and can be implemented efficiently. We demonstrate the expressiveness of the mechanism using significant codebases and evaluate its performance. We have implemented this new exception mechanism as part of the new Genus programming language, but the mechanism could equally well be applied to other programming languages.},
	urldate = {2024-10-19},
	booktitle = {Proceedings of the 37th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Zhang, Yizhou and Salvaneschi, Guido and Beightol, Quinn and Liskov, Barbara and Myers, Andrew C.},
	month = jun,
	year = {2016},
	pages = {281--295},
	
}

@article{biernacki_handle_2017-1,
	title = {Handle with care: relational interpretation of algebraic effects and handlers},
	volume = {2},
	shorttitle = {Handle with care},
	url = {https://dl.acm.org/doi/10.1145/3158096},
	doi = {10.1145/3158096},
	abstract = {Algebraic effects and handlers have received a lot of attention recently, both from the theoretical point of view and in practical language design. This stems from the fact that algebraic effects give the programmer unprecedented freedom to define, combine, and interpret computational effects. This plenty-of-rope, however, demands not only a deep understanding of the underlying semantics, but also access to practical means of reasoning about effectful code, including correctness and program equivalence. In this paper we tackle this problem by constructing a step-indexed relational interpretation of a call-by-value calculus with algebraic effect handlers and a row-based polymorphic type-and-effect system. Our calculus, while striving for simplicity, enjoys desirable theoretical properties, and is close to the cores of programming languages with algebraic effects used in the wild, while the logical relation we build for it can be used to reason about non-trivial properties, such as contextual equivalence and contextual approximation of programs. Our development has been fully formalised in the Coq proof assistant.},
	number = {POPL},
	urldate = {2024-10-20},
	journal = {Proc. ACM Program. Lang.},
	author = {Biernacki, Dariusz and Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	month = dec,
	year = {2017},
	pages = {8:1--8:30},
	
}

@article{ma_lexical_2024,
	title = {Lexical {Effect} {Handlers}, {Directly}},
	volume = {8},
	url = {https://dl.acm.org/doi/10.1145/3689770},
	doi = {10.1145/3689770},
	abstract = {Lexically scoping effect handlers is a language-design idea that equips algebraic effects with a modular semantics: it enables local-reasoning principles without giving up on the control-flow expressiveness that makes effect handlers powerful. However, we observe that existing implementations risk incurring costs akin to the run-time search for dynamically scoped handlers. This paper presents a compilation strategy for lexical effect handlers, adhering to the lexical scoping principle and targeting a language with low-level control over stack layout. Key aspects of this approach are formalized and proven correct. We embody the ideas in a language called Lexa: the Lexa compiler translates high-level effect handling to low-level stack switching. We evaluate the Lexa compiler on a set of benchmarks; the results suggest that it generates efficient code, reducing running-time complexity from quadratic to linear in some cases.},
	number = {OOPSLA2},
	urldate = {2024-10-20},
	journal = {Lexical Effect Handlers, Directly (artifact)},
	author = {Ma, Cong and Ge, Zhaoyi and Lee, Edward and Zhang, Yizhou},
	month = oct,
	year = {2024},
	pages = {330:1670--330:1698},
	
}

@article{muller_capabilities_2023,
	title = {From {Capabilities} to {Regions}: {Enabling} {Efficient} {Compilation} of {Lexical} {Effect} {Handlers}},
	volume = {7},
	shorttitle = {From {Capabilities} to {Regions}},
	url = {https://dl.acm.org/doi/10.1145/3622831},
	doi = {10.1145/3622831},
	abstract = {Effect handlers are a high-level abstraction that enables programmers to use effects in a structured  
way. They have gained a lot of popularity within academia and subsequently also in industry. However,  
the abstraction often comes with a significant runtime cost and there has been intensive research  
recently on how to reduce this price.  

A promising approach in this regard is to implement effect handlers using a CPS translation and  
to provide sufficient information about the nesting of handlers. With this information the  
CPS translation can decide how effects have to be lifted through handlers, i.e., which handlers  
need to be skipped, in order to handle the effect at the correct place. A structured way to make  
this information available is to use a calculus with a region system and explicit subregion  
evidence. Such calculi, however, are quite verbose, which makes them impractical to use as a  
source-level language.  

We present a method to infer the lifting information for a calculus underlying a source-level language.  
This calculus uses second-class capabilities for the safe use of effects. To do so, we define a typed translation  
to a calculus with regions and evidence and we show that this lift-inference translation is typability-  
and semantics-preserving. On the one hand, this exposes the precise relation between the second-class  
property and the structure given by regions. On the other hand, it closes a gap in a compiler pipeline  
enabling efficient compilation of the source-level language. We have implemented lift inference in this  
compiler pipeline and conducted benchmarks which indicate that the approach is indeed working.},
	number = {OOPSLA2},
	urldate = {2024-10-21},
	journal = {Artifact of the paper 'From Capabilities to Regions: Enabling Efficient Compilation of Lexical Effect Handlers'},
	author = {Müller, Marius and Schuster, Philipp and Starup, Jonathan Lindegaard and Ostermann, Klaus and Brachthäuser, Jonathan Immanuel},
	month = oct,
	year = {2023},
	pages = {255:941--255:970},
	
}

@inproceedings{schuster_typed_2022,
	address = {New York, NY, USA},
	series = {{PLDI} 2022},
	title = {A typed continuation-passing translation for lexical effect handlers},
	isbn = {978-1-4503-9265-5},
	url = {https://dl.acm.org/doi/10.1145/3519939.3523710},
	doi = {10.1145/3519939.3523710},
	abstract = {Effect handlers are a language feature which enjoys popularity in academia and  
is also gaining traction in industry. Programs use abstract effect operations  
and handlers provide meaning to them in a delimited scope. Each effect operation  
is handled by the dynamically closest handler. Using an effect operation outside  
of a matching handler is meaningless and results in an error. A type-and-effect  
system prevents such errors from happening.  
Lexical effect handlers are a recent variant of effect handlers with a number of  
attractive properties. Just as with traditional effect handlers, programs use  
effect operations and handlers give meaning to them. But unlike with traditional  
effect handlers, the connection between effect operations and their handler is  
lexical. Consequently, they typically have different type-and-effect systems.  
The semantics of lexical effect handlers as well as their implementations use  
multi-prompt delimited control. They rely on the generation of fresh labels at  
runtime, which associate effect operations with their handlers. This use of  
labels and multi-prompt delimited control is theoretically and practically  
unsatisfactory.  
Our main result is that typed lexical effect handlers do not need the full power  
of multi-prompt delimited control. We present the first CPS translation for  
lexical effect handlers to pure System F. It preserves well-typedness and  
simulates the traditional operational semantics. Importantly, it does so without  
requiring runtime labels. The CPS translation can be used to study the semantics  
of lexical effect handlers as well as as an implementation technique.},
	urldate = {2024-10-21},
	booktitle = {Proceedings of the 43rd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Schuster, Philipp and Brachthäuser, Jonathan Immanuel and Müller, Marius and Ostermann, Klaus},
	month = jun,
	year = {2022},
	keywords = {Contextual\_Reading, Lexical\_Handler},
	pages = {566--579},
	
}

@inproceedings{orchard_embedding_2014,
	address = {New York, NY, USA},
	series = {Haskell '14},
	title = {Embedding effect systems in {Haskell}},
	isbn = {978-1-4503-3041-1},
	url = {https://dl.acm.org/doi/10.1145/2633357.2633368},
	doi = {10.1145/2633357.2633368},
	abstract = {Monads are now an everyday tool in functional programming for abstracting and delimiting effects. The link between monads and effect systems is well-known, but in their typical use, monads provide a much more coarse-grained view of effects. Effect systems capture fine-grained information about the effects, but monads provide only a binary view: effectful or pure.Recent theoretical work has unified fine-grained effect systems with monads using a monad-like structure indexed by a monoid of effect annotations (called parametric effect monads). This aligns the power of monads with the power of effect systems.This paper leverages recent advances in Haskell's type system (as provided by GHC) to embed this approach in Haskell, providing user-programmable effect systems. We explore a number of practical examples that make Haskell even better and safer for effectful programming. Along the way, we relate the examples to other concepts, such as Haskell's implicit parameters and coeffects.},
	urldate = {2024-11-03},
	booktitle = {Proceedings of the 2014 {ACM} {SIGPLAN} symposium on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Orchard, Dominic and Petricek, Tomas},
	month = sep,
	year = {2014},
	pages = {13--24},
	
}

@article{brachthauser_effects_2022,
	title = {Effects, capabilities, and boxes: from scope-based reasoning to type-based reasoning and back},
	volume = {6},
	shorttitle = {Effects, capabilities, and boxes},
	url = {https://dl.acm.org/doi/10.1145/3527320},
	doi = {10.1145/3527320},
	abstract = {Reasoning about the use of external resources is an important aspect of many practical applications. Effect systems enable tracking such information in types, but at the cost of complicating signatures of common functions. Capabilities coupled with escape analysis offer safety and natural signatures, but are often overly coarse grained and restrictive. We present System C, which builds on and generalizes ideas from type-based escape analysis and demonstrates that capabilities and effects can be reconciled harmoniously. By assuming that all functions are second class, we can admit natural signatures for many common programs. By introducing a notion of boxed values, we can lift the restrictions of second-class values at the cost of needing to track degree-of-impurity information in types. The system we present is expressive enough to support effect handlers in full capacity. We practically evaluate System C in an implementation and prove its soundness.},
	number = {OOPSLA1},
	urldate = {2024-11-15},
	journal = {Artifact of the paper "Effects, Capabilities, and Boxes: From Scope-based Reasoning to Type-based Reasoning and Back"},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp and Lee, Edward and Boruch-Gruszecki, Aleksander},
	month = apr,
	year = {2022},
	pages = {76:1--76:30},
	
}

@article{xie_first-class_2022,
	title = {First-class names for effect handlers},
	volume = {6},
	url = {https://dl.acm.org/doi/10.1145/3563289},
	doi = {10.1145/3563289},
	abstract = {Algebraic effects and handlers are a promising technique for incorporating composable computational effects into functional programming languages. Effect handlers enable concisely programming with different effects, but they do not offer a convenient way to program with different instances of the same effect. As a solution to this inconvenience, previous studies have introduced \_named effect handlers\_, which allow the programmer to distinguish among different effect instances. However, existing formalizations of named handlers are both involved and restrictive, as they employ non-standard mechanisms to prevent the escaping of handler names. In this paper, we propose a simple and flexible design of named handlers. Specifically, we treat handler names as first-class values, and prevent their escaping while staying within the ordinary λ-calculus. Such a design is enabled by combining named handlers with \_scoped effects\_, a novel variation of effects that maintain a scope via rank-2 polymorphism. We formalize two combinations of named handlers and scoped effects, and implement them in the Koka programming language. We also present practical applications of named handlers, including a neural network and a unification algorithm.},
	number = {OOPSLA2},
	urldate = {2024-11-18},
	journal = {OOPSLA'22 Paper Artifact: First Class Names for Effect Handlers},
	author = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
	month = oct,
	year = {2022},
	pages = {126:30--126:59},
	
}

@article{xie_generalized_2021,
	title = {Generalized evidence passing for effect handlers: efficient compilation of effect handlers to {C}},
	volume = {5},
	shorttitle = {Generalized evidence passing for effect handlers},
	url = {https://dl.acm.org/doi/10.1145/3473576},
	doi = {10.1145/3473576},
	abstract = {This paper studies compilation techniques for algebraic effect handlers. In particular, we present a sequence of refinements of algebraic effects, going via multi-prompt delimited control, \_generalized evidence passing\_, yield bubbling, and finally a monadic translation into plain lambda calculus which can be compiled efficiently to many target platforms. Along the way we explore various interesting points in the design space. We provide two implementations of our techniques, one as a library in Haskell, and one as a C backend for the Koka programming language. We show that our techniques are effective, by comparing against three other best-in-class implementations of effect handlers: multi-core OCaml, the \_Ev.Eff\_ Haskell library, and the libhandler C library. We hope this work can serve as a basis for future designs and implementations of algebraic effects.},
	number = {ICFP},
	urldate = {2024-11-19},
	journal = {Proc. ACM Program. Lang.},
	author = {Xie, Ningning and Leijen, Daan},
	month = aug,
	year = {2021},
	pages = {71:1--71:30},
	
}

@article{choudhury_recovering_2020,
	title = {Recovering purity with comonads and capabilities},
	volume = {4},
	url = {https://dl.acm.org/doi/10.1145/3408993},
	doi = {10.1145/3408993},
	abstract = {In this paper, we take a pervasively effectful (in the style of ML) typed lambda calculus, and show how to extend it to permit capturing pure expressions with types. Our key observation is that, just as the pure simply-typed lambda calculus can be extended to support effects with a monadic type discipline, an impure typed lambda calculus can be extended to support purity with a comonadic type discipline. We establish the correctness of our type system via a simple denotational model, which we call the capability space model. Our model formalises the intuition common to systems programmers that the ability to perform effects should be controlled via access to a permission or capability, and that a program is capability-safe if it performs no effects that it does not have a runtime capability for. We then identify the axiomatic categorical structure that the capability space model validates, and use these axioms to give a categorical semantics for our comonadic type system. We then give an equational theory (substitution and the call-by-value β and η laws) for the imperative lambda calculus, and show its soundness relative to this semantics. Finally, we give a translation of the pure simply-typed lambda calculus into our comonadic imperative calculus, and show that any two terms which are βη-equal in the STLC are equal in the equational theory of the comonadic calculus, establishing that pure programs can be mapped in an equation-preserving way into our imperative calculus.},
	number = {ICFP},
	urldate = {2024-12-18},
	journal = {Proc. ACM Program. Lang.},
	author = {Choudhury, Vikraman and Krishnaswami, Neel},
	month = aug,
	year = {2020},
	pages = {111:1--111:28},
	
}

@inproceedings{plotkin_handlers_2009,
	address = {Berlin, Heidelberg},
	title = {Handlers of {Algebraic} {Effects}},
	isbn = {978-3-642-00590-9},
	abstract = {We present an algebraic treatment of exception handlers and, more generally, introduce handlers for other computational effects representable by an algebraic theory. These include nondeterminism, interactive input/output, concurrency, state, time, and their combinations; in all cases the computation monad is the free-model monad of the theory. Each such handler corresponds to a model of the theory for the effects at hand. The handling construct, which applies a handler to a computation, is based on the one introduced by Benton and Kennedy, and is interpreted using the homomorphism induced by the universal property of the free model. This general construct can be used to describe previously unrelated concepts from both theory and practice.},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Plotkin, Gordon and Pretnar, Matija},
	editor = {Castagna, Giuseppe},
	year = {2009},
	pages = {80--94},
}

@article{yang_reasoning_2021,
	title = {Reasoning about effect interaction by fusion},
	volume = {5},
	url = {https://dl.acm.org/doi/10.1145/3473578},
	doi = {10.1145/3473578},
	abstract = {Effect handlers can be composed by applying them sequentially, each handling some operations and leaving other operations uninterpreted in the syntax tree. However, the semantics of composed handlers can be subtle---it is well known that different orders of composing handlers can lead to drastically different semantics. Determining the correct order of composition is a non-trivial task.  To alleviate this problem, this paper presents a systematic way of deriving sufficient conditions on handlers for their composite to correctly handle combinations, such as the sum and the tensor, of the effect theories separately handled. These conditions are solely characterised by the clauses for relevant operations of the handlers, and are derived by fusing two handlers into one using a form of fold/build fusion and continuation-passing style transformation.  As case studies, the technique is applied to commutative and distributive interaction of handlers to obtain a series of results about the interaction of common handlers: (a) equations respected by each handler are preserved after handler composition; (b) handling mutable state before any handler gives rise to a semantics in which state operations are commutative with any operations from the latter handler; (c) handling the writer effect and mutable state in either order gives rise to a correct handler of the commutative combination of these two theories.},
	number = {ICFP},
	urldate = {2024-12-24},
	journal = {Proc. ACM Program. Lang.},
	author = {Yang, Zhixuan and Wu, Nicolas},
	month = aug,
	year = {2021},
	pages = {73:1--73:29},
	
}

@inproceedings{brady_resource-dependent_2015,
	address = {Cham},
	title = {Resource-{Dependent} {Algebraic} {Effects}},
	isbn = {978-3-319-14675-1},
	doi = {10.1007/978-3-319-14675-1_2},
	abstract = {There has been significant interest in recent months in finding new ways to implement composable and modular effectful programs using handlers of algebraic effects. In my own previous work, I have shown how an algebraic effect system (called effects) can be embedded directly in a dependently typed host language. Using dependent types ought to allow precise reasoning about programs; however, the reasoning capabilities of effects have been limited to simple state transitions which are known at compile-time. In this paper, I show how effects can be extended to support reasoning in the presence of run-time state transitions, where the result may depend on run-time information about resource usage (e.g. whether opening a file succeeded). I show how this can be used to build expressive APIs, and to specify and verify the behaviour of interactive, stateful programs. I illustrate the technique using a file handling API, and an interactive game.},
	language = {en},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Brady, Edwin},
	editor = {Hage, Jurriaan and McCarthy, Jay},
	year = {2015},
	keywords = {Dependent Type, Functional Programming, Game Rule, Game State, Syntactic Sugar, Idris},
	pages = {18--33},
	
}

@article{brady_programming_2013,
	title = {Programming and reasoning with algebraic effects and dependent types},
	volume = {48},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/2544174.2500581},
	doi = {10.1145/2544174.2500581},
	abstract = {One often cited benefit of pure functional programming is that pure code is easier to test and reason about, both formally and informally. However, real programs have side-effects including state management, exceptions and interactions with the outside world. Haskell solves this problem using monads to capture details of possibly side-effecting computations --- it provides monads for capturing state, I/O, exceptions, non-determinism, libraries for practical purposes such as CGI and parsing, and many others, as well as monad transformers for combining multiple effects.Unfortunately, useful as monads are, they do not compose very well. Monad transformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad. In this paper I describe an alternative approach based on handling algebraic effects, implemented in the IDRIS programming language. I show how to describe side effecting computations, how to write programs which compose multiple fine-grained effects, and how, using dependent types, we can use this approach to reason about states in effectful programs.},
	number = {9},
	urldate = {2025-01-20},
	journal = {SIGPLAN Not.},
	author = {Brady, Edwin},
	month = sep,
	year = {2013},
	keywords = {Idris},
	pages = {133--144},
}

@article{bauer_effect_2014,
	title = {An {Effect} {System} for {Algebraic} {Effects} and {Handlers}},
	volume = {Volume 10, Issue 4},
	issn = {1860-5974},
	url = {https://lmcs.episciences.org/1153},
	doi = {10.2168/LMCS-10(4:9)2014},
	abstract = {We present an effect system for core Eff, a simplified variant of Eff, which is an ML-style programming language with first-class algebraic effects and handlers. We define an expressive effect system and prove safety of operational semantics with respect to it. Then we give a domain-theoretic denotational semantics of core Eff, using Pitts's theory of minimal invariant relations, and prove it adequate. We use this fact to develop tools for finding useful contextual equivalences, including an induction principle. To demonstrate their usefulness, we use these tools to derive the usual equations for mutable state, including a general commutativity law for computations using non-interfering references. We have formalized the effect system, the operational semantics, and the safety theorem in Twelf.},
	urldate = {2025-02-04},
	journal = {Logical Methods in Computer Science},
	author = {Bauer, Andrej and Pretnar, Matija},
	month = dec,
	year = {2014},
	note = {Publisher: Episciences.org},
	
}

@article{karachalias_explicit_2020,
	title = {Explicit effect subtyping},
	volume = {30},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/explicit-effect-subtyping/4851B1C994BEAAB7F04A58B60F11D0AF},
	doi = {10.1017/S0956796820000131},
	abstract = {As popularity of algebraic effects and handlers increases, so does a demand for their efficient execution. Eff, an ML-like language with native support for handlers, has a subtyping-based effect system on which an effect-aware optimising compiler could be built. Unfortunately, in our experience, implementing optimisations for Eff is overly error-prone because its core language is implicitly typed, making code transformations very fragile. To remedy this, we present an explicitly typed polymorphic core calculus for algebraic effect handlers with a subtyping-based type-and-effect system. It reifies appeals to subtyping in explicit casts with coercions that witness the subtyping proof, quickly exposing typing bugs in program transformations. Our typing-directed elaboration comes with a constraint-based inference algorithm that turns an implicitly typed Eff-like language into our calculus. Moreover, all coercions and effect information can be erased in a straightforward way, demonstrating that coercions have no computational content. Additionally, we present a monadic translation from our calculus into a pure language without algebraic effects or handlers, using the effect information to introduce monadic constructs only where necessary.},
	language = {en},
	urldate = {2025-02-04},
	journal = {Journal of Functional Programming},
	author = {Karachalias, Georgios and Pretnar, Matija and Saleh, Amr Hany and Vanderhallen, Stien and Schrijvers, Tom},
	month = jan,
	year = {2020},
	pages = {e15},
	
}

@inproceedings{lindley_algebraic_2014,
	address = {New York, NY, USA},
	series = {{WGP} '14},
	title = {Algebraic effects and effect handlers for idioms and arrows},
	isbn = {978-1-4503-3042-8},
	url = {https://dl.acm.org/doi/10.1145/2633628.2633636},
	doi = {10.1145/2633628.2633636},
	abstract = {Plotkin and Power's algebraic effects combined with Plotkin and Pretnar's effect handlers provide a foundation for modular programming with effects. We present a generalisation of algebraic effects and effect handlers to support other kinds of effectful computations corresponding to McBride and Paterson's idioms and Hughes' arrows.},
	urldate = {2025-02-05},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} workshop on {Generic} programming},
	publisher = {Association for Computing Machinery},
	author = {Lindley, Sam},
	month = aug,
	year = {2014},
	pages = {47--58},
	
}

@article{karachalias_efficient_2021,
	title = {Efficient compilation of algebraic effect handlers},
	volume = {5},
	url = {https://dl.acm.org/doi/10.1145/3485479},
	doi = {10.1145/3485479},
	abstract = {The popularity of algebraic effect handlers as a programming language feature for user-defined computational effects is steadily growing. Yet, even though efficient runtime representations have already been studied, most handler-based programs are still much slower than hand-written code. This paper shows that the performance gap can be drastically narrowed (in some cases even closed) by means of type-and-effect directed optimising compilation. Our approach consists of source-to-source transformations in two phases of the compilation pipeline. Firstly, elementary rewrites, aided by judicious function specialisation, exploit the explicit type and effect information of the compiler’s core language to aggressively reduce handler applications. Secondly, after erasing the effect information further rewrites in the backend of the compiler emit tight code. This work comes with a practical implementation: an optimising compiler from Eff, an ML style language with algebraic effect handlers, to OCaml. Experimental evaluation with this implementation demonstrates that in a number of benchmarks, our approach eliminates much of the overhead of handlers, outperforms capability-passing style compilation and yields competitive performance compared to hand-written OCaml code as well Multicore OCaml’s dedicated runtime support.},
	number = {OOPSLA},
	urldate = {2025-02-19},
	journal = {Compiler and replication of results: "Efficient Compilation of Algebraic Effect Handlers"},
	author = {Karachalias, Georgios and Koprivec, Filip and Pretnar, Matija and Schrijvers, Tom},
	month = oct,
	year = {2021},
	pages = {102:1--102:28},
	
}

@article{leijen_type_2017,
	title = {Type directed compilation of row-typed algebraic effects},
	volume = {52},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/3093333.3009872},
	doi = {10.1145/3093333.3009872},
	abstract = {Algebraic effect handlers, introduced by Plotkin and Power in 2002,  are recently gaining in popularity as a purely functional approach to  modeling effects. In this article, we give a full overview of  practical algebraic effects in the context of a compiled  implementation in the Koka language. In particular, we show how  algebraic effects generalize over common constructs like exception  handling, state, iterators and async-await. We give an effective type  inference algorithm based on extensible effect rows using scoped  labels, and a direct operational semantics. Finally, we show an  efficient compilation scheme to common runtime platforms (like  JavaScript) using a type directed selective CPS translation.},
	number = {1},
	urldate = {2025-04-15},
	journal = {SIGPLAN Not.},
	author = {Leijen, Daan},
	month = jan,
	year = {2017},
	pages = {486--499},
	
}

@article{song_specification_2024-1,
	title = {Specification and {Verification} for {Unrestricted} {Algebraic} {Effects} and {Handling}},
	volume = {8},
	url = {https://dl.acm.org/doi/10.1145/3674656},
	doi = {10.1145/3674656},
	abstract = {Programming with user-defined effects and effect handlers has many practical use cases involving imperative effects. Additionally, it is natural and powerful to use multi-shot effect handlers for non-deterministic or probabilistic programs that allow backtracking to compute a comprehensive outcome. Existing works for verifying effect handlers are restricted in one of three ways: i) permitting multi-shot continuations under pure setting; ii) allowing heap manipulation for only one-shot continuations; or iii) allowing multi-shot continuations with heap-manipulation but under a restricted frame rule.
 

 
This work proposes a novel calculus called Effectful Specification Logic (ESL) to support unrestricted effect handlers, where zero-/one-/multi-shot continuations can co-exist with imperative effects and higher-order constructs. ESL captures behaviors in stages, and provides precise models to support invoked effects, handlers and continuations. To show its feasibility, we prototype an automated verification system for this novel specification logic, prove its soundness, report on useful case studies, and present experimental results. With this proposal, we have provided an extended specification logic that is capable of modeling arbitrary imperative higher-order programs with algebraic effects and continuation-enabled handlers.},
	number = {ICFP},
	urldate = {2025-05-03},
	journal = {Specification and Verification for Unrestricted Algebraic Effects and Handling},
	author = {Song, Yahui and Foo, Darius and Chin, Wei-Ngan},
	month = aug,
	year = {2024},
	pages = {267:909--267:937},
	
}

@article{tang_modal_2025,
	title = {Modal {Effect} {Types}},
	volume = {9},
	url = {https://dl.acm.org/doi/10.1145/3720476},
	doi = {10.1145/3720476},
	abstract = {Effect handlers are a powerful abstraction for defining, customising, and composing computational effects. Statically ensuring that all effect operations are handled requires some form of effect system, but using a traditional effect system would require adding extensive effect annotations to the millions of lines of existing code in these languages. Recent proposals seek to address this problem by removing the need for explicit effect polymorphism. However, they typically rely on fragile syntactic mechanisms or on introducing a separate notion of second-class function. We introduce a novel approach based on modal effect types.},
	number = {OOPSLA1},
	urldate = {2025-05-04},
	journal = {Proc. ACM Program. Lang.},
	author = {Tang, Wenhao and White, Leo and Dolan, Stephen and Hillerström, Daniel and Lindley, Sam and Lorenzen, Anton},
	month = apr,
	year = {2025},
	pages = {120:1130--120:1157},
	
}
